<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【面试笔记】Python，Django]]></title>
    <url>%2F2019%2F05%2F29%2F%E3%80%90%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%E3%80%91Python%EF%BC%8CDjango%2F</url>
    <content type="text"><![CDATA[DjangoDjango框架快速上手，是超多开箱即用的工具，快速开发的优先选择。它是由Python写成,采用了MTV的框架模式.即Model, View, Template组成。 说到底,其实Django内部就是对Socket连接的强大封装。 模型（Model），即数据存取层（与数据库处理有关的程序）。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。 模板(Template)，即表现层（各种html程序）。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 视图（View），即业务逻辑层（url的处理函数）。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。 Django文件结构123456789101112├── django/ # 项目文件夹，对整个项目进行配置│ ├── setting.py # 项目配置文件│ ├── urls.py # url对应关系，对url的正则表达式分配相应视图│ ├── wsgi.py # 遵循WSIG规范, uwsgi + nginx│ └── manage.py # 管理Django 程序├── app/ # app， 应用程序文件夹│ ├── migrations/ # 数据库操作记录，相应表结构发生变化│ ├── admin.py # Django为我们提供的后台管理│ ├── apps.py # 配置当前APP│ ├── models.py # ORM,写指定的类通过命令可以创建数据库结构│ ├── tests.py # 单元测试│ └── views.py # 业务逻辑代码 Django原理Django请求的生命周期 当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端, 请求头和请求体中会包含浏览器的动作(action),这个动作通常为get或者post,体现在url之中. url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. 视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django把客户端想要的数据做为一个字符串返回给客户端. 客户端浏览器接收到返回的数据,经过渲染后显示给用户. 业务流程原理url请求—-&gt;访问路由系统(负责分发请求到相应视图函数)——&gt;视图函数(处理请求)——&gt;DataBase(数据库操作数据生成对应页面返回给用户)这个过程中Django主要做了两件事：处理 Request和创建Response， 而它们对应的核心就是urls分析、模板技术和ORM技术。 具体步骤如下： 用户通过浏览器请求一个页面 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求 URLConf通过urls.py文件和请求的URL找到相应的View View Middlewares被访问，它同样可以对request做一些处理或者直接返回response 调用View中的函数 View中的方法可以选择性的通过Models访问底层的数据 底层实现原理本质是Django就是一个Socket服务端,用户的浏览器其实就是一个Socket客户端.用户访问网站的过程就是服务端与客户端Socket通信的过程。 WSGI协议WSGI TutorialWSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。uwsgi：与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等 WSGI协议主要包括server和application两部分： WSGI server: 负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application: 接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。 WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和application组合实现自己的web应用。 Django WSGI applicationWSGI application接口应该实现为一个可调用对象，例如函数、方法、类、含call方法的实例。这个可调用对象可以接收2个参数： 一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env）； 一个用于发送HTTP响应状态（HTTP status ）、响应头（HTTP headers）的回调函数。同时，可调用对象的返回值是响应正文（response body），响应正文是可迭代的、并包含了多个字符串。 可以看出application的流程包括: 加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号； 处理请求，调用get_response()方法处理当前请求，该方法的的主要逻辑是通过urlconf找到对应的view和callback，按顺序执行各种middleware和callback。 调用由server传入的start_response()方法将响应header与status返回给server。 返回响应正文 Django WSGI Server负责获取http请求，将请求传递给WSGI application，由application处理请求后返回response。 配置服务器: Nginx vs ApacheNginx相对Apache 的优点： 轻量级，同样起web 服务，比apache占用更少的内存及资源 抗并发，Nginx处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下Nginx 能保持低资源低消耗高性能高度模块化的设计，编写模块相对简单 社区活跃，各种高性能模块出品迅速啊 Nginx配置简洁, Apache复杂 Apache相对Nginx的优点： rewrite ，比nginx的rewrite强大 模块超多，基本想到的都可以找到 少bug ，nginx的bug相对较多超稳定 Nginx的优势是处理静态请求，cpu内存使用率低，Apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程。需要性能的web服务，用Nginx。如果不需要性能只求稳定，那就Apache。 Django内置组件 Admin是对model中对应的数据表进行增删改查提供的组件 model组件：负责操作数据库 form组件：1.生成HTML代码2.数据有效性校验3校验信息返回并展示 ModelForm组件即用于数据库操作,也可用于用户请求的验证 Django中间件 process_request : 请求进来时,权限认证 process_view : 路由匹配之后,能够得到视图函数 process_exception : 异常时执行 process_template_responseprocess : 模板渲染时执行 process_response : 请求有响应时执行 cookie vs session cookie: cookie是保存在浏览器端的键值对,可以用来做用户认证 session：将用户的会话信息保存在服务端,key值是随机产生的字符串,value值是session的内容, 依赖于cookie将每个用户的随机字符串保存到用户浏览器上Django中session默认保存在数据库中：django_session表 参考资料 Python篇-Django框架详解(一) Django框架–底层架构 理解Python WSGI 做python Web开发你要理解：WSGI &amp; uwsgi Django面试题(21道) Python全局解释器锁线程全局锁(Global Interpreter Lock), 即Python为了保证线程安全而采取的独立线程运行的限制, 说白了就是一个CPU只能在同一时间运行一个线程. 无论系统上存在多少个可用的CPU核心，Python程序只能在一个处理器上运行。]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【重读课本】操作系统概念]]></title>
    <url>%2F2019%2F05%2F29%2F%E3%80%90%E9%87%8D%E8%AF%BB%E8%AF%BE%E6%9C%AC%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[最近找工作的过程中，面试都问到了操作系统，而且是操作系统很基础的知识。然而，我都忘了… 换句话说，你忘了，就是在面试官心目中你不会。为了不再丢人，我决定好好重读课本，也算是巩固一下基础，努力做个好程序员。 因为面试过程中问的比较多的是进程和线程。那我就不按课本的顺序，先从线程开始。 进程 &amp;概念 进程： 一个程序在一个数据集合上的一次运行。所以一个程序在不同的数据集合上运行，乃至一个程序在同样的数据集合上的多次运行都是不同的进程。（如，浏览器打开多个页面） 线程：线程是进程中的一个实体，是被系统独立调度和执行的基本单位。 作业：用户在一次解题或一个事务处理过程中要求计算机系统所做的工作的集合。它包括用户程序，所需要的数据以及控制命令等。作业是一系列有序的步骤组成的。 管程：管程实际上是定义了一个数据结构和在该数据结构上的能为并发进程所执行的一组操作，这组操作能同步进程和改变进程中的数据。 进程状态 就绪(Ready): 当进程已分配到了除CPU以外的所有必要的资源，只要获得处理器就可以立即执行 执行(Running): 当进程获得了处理器，程序真正处理器上执行 阻塞(Blocked): 正在执行的进程，由于等待某个事件的发生而无法执行时，就放弃处理器而处于阻塞状态。引起阻塞的事件很多，如等待IO，申请缓冲区不能满足，等待信号等等 线程为什么需要线程在完成一个事件如果要创建多个进程实现（如MP3播放器），多个进程又存在问题： - 进程之间通信和共享资源开销大 - 维护进程的系统开销大：创建进程时，要分配资源和建立PCB；撤销进程时，回收资源和撤销PCB；进程切换时，保存当前进程的状态。 线程与进程的比较 进程时资源分配单位，线程时CPU的调度单位； 进程拥有一个完整的资源平台，线程只独享不可少的的资源如寄存器和栈。 进程间是独立的，这表现在内存空间和上下文环境上，线程是运行在进程空间内。 通常情况下，进程无法存储其他进程内的存储空间；而线程与它同属一进程的其他线程共享代码段，数据段和其他操作系统资源，它们共享同一内存空间； 同一进程中的两段代码不能同时执行，除非引入多进程 线程是属于进程的，当进程退出时该进程产生的所有线程都会被强制退出并清除。 进程间有IPC通信，线程没有 线程同样有就绪，阻塞和执行三种基本状态 线程能减少并发执行的时间和空间开销： 线程的创建时间比进程短 线程的终止时间比进程短 同一进程内的线程切换时间比进程短 由于同一进程的各线程之间共享内存和文件资源，可以直接进行不需要通过内核的通信 动态链接库 VS 静态链接库静态库包括了代码，地址符号等；而导入库（动态库）实际的执行代码位于动态库中。静态库要参与编译，在生成执行文件工程中，要将静态库的所有指令全部接入执行文件中。所以，生成执行文件后，静态链接库.lib文件可以弃之不用。动态链接库是作为共享函数的可执行文件。动态链接提供一个方法，使进程可以调用不属于它的可执行代码的函数。函数的执行代码位于.dll文件中，它包含了一个或多个已经被编译，链接并于使它们的进程的函数。 dll的优点：节省内存，减少交换操作，节省磁盘空间，更易于升级（不需要重链接和重编译），提供售后服务，提供拓展MFC库类的机制，支持多语言程序。静态链接库可能比动态链接库快。 进程之间的通信进程之间的通信有：信号，管道，消息队列，共享内存 信号：操作系统向应用程序发出信号，应用程序会：crash(直接退出)， ingore，catch(获取信号并处理，处理完后再回到原来的程序继续执行)。但是信号不能共享数据段。 管道：某个进程的输出是某个进程的输入，由操作系统决定 消息队列： 直接通信：建立链接 间接通信：一个消息队列可以被多个进程所共享；共享消息队列的进程发送的消息中除了message本身外还有一个标志，这个标志可以指明该消息由哪个进程或哪类进程接受。每一个共享消息队列也有自己的标志，表明自己的身份 共享内存： 通常操作系统试图阻止一个进程访问另外一个进程的内存。共享内存需要两个或更多的进程取消这个限制， 它们通过在共享区域内读写交换信息。 数据的形式或位置取决于这些进程而不受控于操作系统。 进程还要保证它们不向同一区域同时写数据：生产者–消费者；如一个Web服务器生产（提供）HTML文件和图像，它们被请求资源的客户Web浏览器所消费(读取)。 死锁死锁产生条件： - 互斥条件 - 请求与保持条件 - 不剥夺条件 - 循环等待条件 占有一些资源，并循环等待 预防和解除： - 对进程发出的能过满足的资源请求进行动态检查，并根据检查结果决定是否分配资源 - 防止进程在等待状态的情况下占有资源 处理死锁基本方法: - 预防死锁(摒弃除1以外的条件) - 避免死锁(银行家算法) - 检测死锁(资源分配图) - 解除死锁 - 剥夺资源 - 撤销进程 调度]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Operating System</tag>
        <tag>重读</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2F2019%2F05%2F29%2Fhexo-notes%2F</url>
    <content type="text"><![CDATA[Hexo的官方文档如下： https://hexo.io/docs/https://hexo.io/zh-cn/docs/ 为了方便，我把一些常用的指令记录下来。 常用指令 new: 新建一篇文章 1$ hexo new [layout] &lt;title&gt; Hexo 有三种默认布局：post、page 和 draft。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate: 生成静态文件 1$ hexo generate 选项: - -d, --deploy: 文件生成后立即部署网站 - -w, --watch: 监视文件变动 该指令可以简写为 hexo g publish: 发表草稿 1$ hexo publish [layout] &lt;filename&gt; server: 启动本地服务器 1$ hexo server 默认情况下，访问网址为： http://localhost:4000/。 deploy: 部署 1$ hexo deploy 该命令可以简写为：hexo d clean: 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean 在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那就可能需要运行该命令。 list: 列出网站资料 1$ hexo list &lt;type&gt; Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量。预定义的参数有：layout, title, date, updated, comments, tags, categories, permalink. 并列分类：123categories:- [Linux]- [Tools] 并列+子分类：123categories:- [Linux, Hexo]- [Tools, PHP] 参考资料 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 Hexo 搭建个人博客系列：主题美化篇 用Live2D让看板喵入住你的Hexo博客吧(^o^)/~]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing testst Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
