<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【系统设计】新鲜事系统]]></title>
    <url>%2F2019%2F06%2F21%2Fsystem-design-introduction-news-feed%2F</url>
    <content type="text"><![CDATA[系统设计面试是常见的一种面试类型，特别是针对后端工程师，全栈工程师是必须的面试环节。 需要面试系统设计的情况如下： 刚毕业的学生 已经有工作经验的工程师 面试全栈工程师 面试后端工程师 面试系统架构师 现在的系统设计大部分时候面试的内容都是与 Web 开发相关的知识，因为大部分的公司都需要 Web Backend Engineer。因此只要面试和后端有关的职位，都有可能会面到系统设计，无论是刚毕业的学生还是已经有工作经验的工程师。特别的，机器学习（ML）相关的职位会面与机器学习有关的设计问题，一般不会面系统设计。Manager 相关的岗位也不会面系统设计。实习生很少很少很少会面系统设计，一般两轮算法题就OK了。Data 相关的职位一般也不会面试系统设计。 系统设计面试的两种形式 及 常见的系统设计面试问题： ➔ (题目都是比较短小) 设计某某系统 Design XXX System 设计微博 Design Twitter 设计人人 Design Facebook 设计滴滴 Design Uber 设计微信 Design Whatsapp 设计点评 Design Yelp 设计短网址系统 Design Tiny URL 设计NoSQL数据库 Design NoSQL 设计某某系统中的某某功能 设计一个功能实现对用户访问频率的限制 设计一个功能实现统计某个具体事件的历史发生次数 (如Facebook的点赞，有读有写，可以监控整个系统健康程度) 设计删除一个 Tweet 的功能 设计邮件系统中将所有邮件标记为已读的功能 找问题 网站挂了怎么办 网站太慢怎么办 流量增长怎么办 系统设计和面向对象设计的对比： 系统设计是宏观设计，通常考察的是系统的架构能力，工作经验，一般都是以聊天的形式为主。通过聊天来了解你知不知道这个，懂不懂那个。 考察的知识点：Database, Schema, SQL, NoSQL, Memcached, File System, Distributed System, Latency, Scalbility, Master Slave, Load Balancer, Web Server, Message Queue, Sharding, Consistent Hashing, QPS … 典型题：短网址系统设计，新鲜事系统设计 面向对象设计是微观设计。通常是让你实现一些非常具体的功能，你需要用面向对象编程实现一个类（Class）以及定义在这个类上个方法（method）。通常一半时间聊天，一半时间写代码。 考察的知识点：Class, Object, Method, Inheritance, Interface … （考虑PC端, frontend design） 典型题：电梯设计，游戏设计 设计新鲜事系统(News Feed) ➔ 类似微博、朋友圈、Twitter、Facebook的系统： 什么是新鲜事 News Feed： 你登陆 Facebook / Twitter / 朋友圈 之后看到的信息流 你的所有朋友发的信息的集合 核心因素： 关注与被关注 每个人看到的新鲜事都是不同的 系统设计面试评分标准： 可行解 Work Solution 25% 特定问题 Special Case 20% 分析能力 Analysis 25% 权衡 Tradeoff 15% 知识储备 Knowledge Base 15% 系统设计： 4S分析法 Scenario 场景 需要设计哪些功能、到哪个程度 询问： Features / QPS / DAU / Interfaces Service 服务 将大系统拆分为小服务 拆分、Application、模块化 Storage 存储（比较核心的部分） 数据如何存储与访问 Schema/Data/SQL/NoSQL/File System Scale 升级 解决缺陷，处理可能遇到的问题 Sharding/ Optimize / Special Case 通过Scenario，Service， Storage后可以得到了Work Solution但不一定是Perfect Solution。通过Scale可以优化系统。系统设计按照这个思路去思考，去准备，去设计， 使得面试过程中有章法有套路。 设计Twitter为例子场景场景连问 需要设计哪些功能？ 需要承受多大访问量？ DAU - 150M+ (日活跃用户 - DAU - Daily Active User) MAU 313M （估算：MAU ≈ DAU / 2） MAU 衡量网站用户数的重要指标：用户量大，读写自然就大了 功能设计 枚举功能： 把Twitter的功能一个个罗列出来 注册、登录 用户个人主页 发、分享微博 上传图片、视频 搜索 时间线、信息流 ➔ timeline, news feed 关注、取关 对功能排序： 选出核心功能，因为你不可能这么短的时间什么都设计 Post a Tweet Timeline News Feed Follow / Unfollow a user Register / Login 分析&amp;预测 并发用户： 日活跃*每个用户平均请求次数/一天多少秒 = … = 100k 峰值 Peak = Average Concurrent User * 3 ~ 300k 快速增长的产品 —— MAX peak users in 3 mouth = Peak users * 2 通过DAU, MAU估算出QPS 读频率 —— Read QPS (Queries Per Second) 300k 写频率 —— Write QPS 5K 分析出QPS有什么用？ QPS = 100 笔记本做Web服务器就可以 QPS = 1K 好点的Web服务器就行 需要考虑Single Point Failure（万一某服务挂了） QPS = 1M 考虑建设一个1000台的Web服务器集群 需要考虑维护问题（万一一台挂了） QPS和Web Server(服务器) / Database(数据库) 之间的关系 QPS和 Web Server (服务器) / Database (数据库) (Apache 和 Nginx 的吞吐量都有几十万，是按照有很牛的机器做比较简单的操作。普通机器QPS能达10算好了…) 一台Web Server（企业级）承受量大约为1k的QPS (考虑到逻辑处理时间以及数据库查询的瓶颈) 一台SQL Database 承受量是1k的QPS (如果JOIN和INDEX 请求比较多，这个值会更小) 一台NoSQL Database (Cassandra) 约承受量是10k的QPS 一台NoSQL Database (内存cache型的, Memchached) 约承受量是1M的QPS 服务将大系统拆分为小服务： ➔ 微服务 Replay： 重新过一遍每个需求，为每个需求添加一个服务 Merge： 归并相同的服务 什么是服务 Service? 可以认为是逻辑处理的整合 对于同一类问题的逻辑处理归并在一个 Service 中 把整个 System 细分为若干个小的 Service 服务拆解的例子Router： 通常是在 Web Framework 中负责根据 url 的不同的路径，将用户的请求分配给不同的 service 去处理的这么一个路由函数。如看到 /users/ 开头的 url 就丢给 UserService，看到 /tweets/ 开头的就丢 TweetService。 ※ 存储存储 ➔ 最重要数据如何存储与访问： Select： 为每个 Application / Service 选择合适的存储结构 Schema： 细化数据表结构 数据如何存储与访问 数据库系统 Database 关系型数据库 SQL Database 用户信息 User Table 非关系型数据库 NoSQL Database 推文 Tweets 社交图谱 Social Graph (followers) 文件系统 File System 图片、视频 Media File 缓存系统 Cache ➔ (通常配合数据库使用) 不支持数据持久化 Nonpersistent 效率高，内存级访问速度 可以说： 程序 = 算法 + 数据结构 系统 = 服务 + 数据存储 例子，也就是可以按照如下图所示设计Twitter的数据存储：细化Twitter的数据表结构： 信息流(News Feed)如何存取Pull模型：读扩散Pull模型：用户查看news feed时，获取每个好友前100条微博，合并出前100条 主动读取：用户需要的时候再算 K路归并算法：(时间复杂度为O(nlogk)) 使用堆 每两两个链表合并，自下而上 类似归并排序，自上而下 时间复杂度： News Feed ➔ 假如有N个关注对象，则复杂度 = N次DB Reads的时间（O(100N)） + K路归并时间（可忽略，由于数据获取是瓶颈） Post a tweet ➔ 1次DB Write的时间 Read的慢是用户可感知的 Pull模型原理如下： 用户发送请求消息 获取关注列表 获取关注列表的前100条Tweets merge之后返回 Pull模型的缺陷：N次DB Reads非常慢 且发生在用户获得News Feed的请求过程中， Read的慢是用户可感知的慢 Push模型：写扩散Push模型： 一个News Feed Table存储所有用户的News Feed 为每个用户建一个List存储他的News Feed信息(虚拟的list，从表中根据ower_id filter出list) 用户发一个Tweet之后，将该推文逐个推送到每个用户的News Feed List中(关键词:Fanout) 用户需要查看News Feed时，只需要从该News Feed List中读取最新的100条即可 (可放入cache中) “Disk is cheap”，不要怕浪费数据库存储，为了加速查询，多存一些东西是没关系的。 复杂度分析： News feed =&gt; 1次DB Read 在 Needs Feed Table 可以建 composite index Post a tweet =&gt; N个粉丝，需要N次DB Writes 用户只需要知道有没有发成功 好处是Fanout过程可以用异步任务在后台执行，无需用户等待 Push模型原理如下： 用户发布一个新的tweet 把tweet写入数据库 同时把新的tweet更新到好友的信息流中，新建一个异步任务，放入message queue 获得粉丝列表 Fanout：把新的tweet写入到粉丝的news feed中 Push模型的缺陷： 不及时。粉丝数目可能很大，导致 Fanout 过程很长，从而导致用户刷到新鲜事有延迟。 浪费系统资源去为很多僵尸粉创建新鲜事记录。 明星发帖会在短时间内为系统带来很大的处理压力。 Poll vs Push大厂大部分都是 Pull 或者 Pull + Push 因为要考虑明星的问题，小厂一般直接 Push，因为代码简单，容易维护。如果没有明星问题的产品，如朋友圈，也可以用 Push，因为不会有明星问题。使用Poll 和 Push 都可以，遇到问题可以尝试优化。 热门Social App的模型： Facebook – Pull Instagram – Push + Pull Twitter – Pull 误区：1）不坚定想法，摇摆不定；2）不能表现出Tradeoff的能力3）无法解决特定的问题 扩展通过前三步可以得到一个 Work Solution 而不是 Perfect Solution， 这个Work Solution 可以存在很多待解决的缺陷， 故可以使用Scale来优化和维护 Optimize：如何优化系统 解决设计缺陷 Pull vs Push, Normalize vs De-normalize 更多功能设计 Like, Follow &amp; Unfollow, Ads 一些特殊用例 明星用户的精群效应，僵尸粉 解决Pull的缺陷由于最慢的部分发生在用户读请求时，那么可以: 在DB访问之前加入Cache，常用会使用memcached，相当于是数据库的cache Cache每个用户的timeline： N次DB请求 ➔ N次Cache请求 (N是你关注的好友个数), 从数据库中读取改为从Cache中读取，而数据库的读取速度和Cache的读取速度的差是100～1000倍 Trade off: 可以只考虑最近的1000条之类的（其实200条也可以了），不要太浪费内存 Cache每个用户的News feed： 没有Cache News Feed的用户：归并N个用户最近的100条tweets，然后取出结果的前100条。不是时时有新的更新。 有Cache News Feed的用户：归并N个用户在某个时间戳之后的所有tweets 解决Push缺陷 浪费Disk空间 但其实没啥, Disk is cheap 不活跃用户 粉丝排序。但也没啥作用 大量粉丝问题，无解。因此可以尝试在现有的模型下进行优化(加几个机器)。还可以对长期增长进行估计，并评估是否值得转化整个模型。 做个trade off: Pull + Push vs Pull Push 结合 Pull 的优化方案算法过程： 普通的用户仍然 Push 将 Lady Gaga 这类的用户，标记为明星用户 对于明星用户，不 Push 到用户的 News Feed 中 当用户需要的时候，来明星用户的 Timeline 里取，并合并到 News Feed 里 明星用户： 是不是明星不能在线动态计算，要离线计算（为 User 增加一个 is_superstar 的属性） Pull vs Push 为什么既然大家都用Pull，我们仍然要学习Push? 系统设计不是选择一个最好的方案 而是选择一个最合适的方案 如果你没有很大的流量，Push是最经济最省力的做法 什么时候用 Push? 资源少 想偷懒，少写代码 实时性要求不高 用户发帖比较少 双向好友关系，没有明星问题(比如朋友圈) 什么时候用 Pull ? 资源充足 实时性要求高 用户发帖很多 单向好友关系，有明星问题 (如Facebook，有复杂的要求时) Maintenance 鲁棒性 Robust 如果有一台服务器/数据库挂了怎么办 扩展性 Scalability 如果有流量暴增，如何扩展 其解决方案见下一节。 总结 4S分析法： 不是面试过程中每一个步骤都要踩到，要心里有谱，如果面试官给的问题比较虚无缥缈时，可以考虑一下，如果有具体的问题，非常清晰的场景，就可以按照这个来回答。 Ask before design：问清楚再动手设计 不要一上来就冲着一个巨牛的方案去设计，切忌不要做关键词大师。 No more no less：不要总想着设计最牛的系统 要设计够用的系统 Analysis is important than solution：系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊。 拓展Q1：关注和取关 Follow &amp; Unfollow：无论使用什么模型，都需要在数据库中创建/删除记录 对于Push model： Follow 一个用户之后，异步地将他的 Timeline 合并到你的 News Feed 中 Unfollow 一个用户之后，异步地将他发的 Tweets 从你的 News Feed 中移除 需要异步 Async 的原因： 因为这个过程一点都不快呀，(有很多的数据) 异步的好处： 用户迅速得到反馈，似乎马上就 follow / unfollow 成功了 异步的坏处： Unfollow 之后刷新 News Feed，发现好像他的信息还在， 有延迟 不过最终还是会被删掉的 Q2：如何存储likes如何在 News Feed 中同时得到每个帖子被点赞、评论和转发的次数？ 有两种方法：Normalize 和 Denormalize Normalize 获得点赞数的方式: 1SELECT COUNT * FROM like_table where tweet_id=xxx; 优点:标准化，最准确。 缺点:炒鸡慢，会增加 O(N) 个 SQL Queries(对于某一页的 Tweets，每个都得来这么一句查询) Denormalize 获得点赞数的方式: Denormalize 是在 Like Table 中也还是继续新增一条记录，并且 update TweetTable 里的 like_count。 （对于关注和取关的问题，也是有记录他的粉丝人数和关注的人数也是使用de-normalize记录） 当有人点赞的时候: 1UPDATE like_table SET num_of_likes = num_of_likes + 1 where tweet_id = xxx 当有人取消赞的时候: 1UPDATE like_table SET num_of_likes = num_of_likes - 1 where tweet_id = xxx 想要获得一个 Tweet 的点赞数时，因为 num_of_likes 就存在 tweet 里，故无需额外的 SQL Queries时间复杂度为O(1)，虽然记录了冗余信息，但是使用了空间换取了时间 Q3：惊群现象惊群现象(Thundering Herd)：对于同一条数据短时间出现大量的请求。因为访问的是同一个数据，sharding 机制无论如何都会 sharding 到同一个机器上。此时 sharding 不能做到分摊流量的作用。➔数据库承受不住压力 我们通常会使用缓存来作为数据库的“挡箭牌”，优化一些经常读取的数据的访问速度。即，在访问这些数 据时，会先看看是否在缓存中，如果在，就直接读取缓存中的数据，如果不在，就从数据库中读取之后，写入缓存并返回。 那么在高并发的情况下，如果一条非常热的数据，因为缓存过期或者被淘汰算法淘汰等原因，被踢出缓存之后，会导致短时间内(&lt;1s)，大量的数据请求会出现缓存穿透 (Cache miss)，因为数据从 DB 回填到 Cache 需要时间。从而这些请求都会去访问数据库，导致数据库处理不过来而崩溃，从而影响到其他数据的访问而导致整个网站崩溃。 解决办法及参考资料： Memcache Lease Get - 《Scaling Memcache at Facebook》给普通的memcache增加lease get功能：对于读取同一条数据，只有第一个请求去访问数据库，把数据从DB中取出，然后回填到cache； 其他请求都在等着。（取肉夹馍例子） Redis 防雪崩架构设计 常见QACache Cache是一个相对概念 可以是在内存中 可以是在磁盘上 可以是在CPU里（L1 Cache / L2 Cache) 可以是在服务器端 可以是在客户端（如浏览器cache） 在浏览器中访问某个网页时，第一次比较慢，再访问一次后会比较快，因为浏览器会把一些图片等文件cache在浏览器中 内存中的 Cache 可以理解为一个 Hash Table，是一种 key-value 的结构 常用的Cache工具/服务器有：Memcached，Redis 我们通常把经常访问的数据放在Cache里来加速访问速度， （访问内存比访问数据库快很多） Cache 因为空间受限制，因此需要淘汰掉一些不常用的数据 常见的淘汰算法有LRU（Least Recently Used）是算法面试中常见的考点 为什么不全放Cache里? 内存中的数据断电就会丢失 Cache 比硬盘贵 消息队列 消息队列是什么 消息队列是 进程间通信 或 同一进程的不同线程间的通信方式 简单的说就是一个先进先出的任务队列列表，队列里放的是任务信息(PID之类) 做任务的worker进程共享同一个列表 (worker监听消息队列，一旦有新的任务就取下来然后执行，执行结果一般不是通过消息队列返回，而是可以通过把结果写入到数据库中，web server通过时不时看一下数据库或者通过用户刷新来读取任务执行情况，通过这样的方式来完成web server和数据库之间协同工作) Workers从列表中获得任务去做，做完之后反馈给队列服务器 队列服务器是做异步任务必须有的组成部分 什么时候使用消息队列 “生产者消费者”模型 里面使用到的queue, 这个queue起到了缓冲的作用 需要缓冲的原因：处理消息和发送消息（产生消息）的速率不一致 例子：(下单网购和送快递)，OJ交代码和评测机评测，发激活邮件(使用第三方API，由于和远程机器通信故速度慢，且如果失败了会重新发送)，12306订票 使用场景： 任务执行比较慢 使用重试机制 用户愿意去等待(如使用Push模型时关注/取关一个用户) 哪些工具可以做消息队列 最常用的有 RabbitMQ, Redis, AWS SQS, ZeroMQ, Kafk 其他机制(optional)： 两个worker同时工作时，不会取到一样的任务去执行 镜像机制（double master） 有些任务是有优先级（里面有子queue） NewsFeed 如何实现 Pagination?问：是不是不管push还是pull模型，如果翻页的话都得pull?翻页是用户主动操作的过程，所以肯定是由client 发给 server，肯定是一个pull的过程。 问：假设前100条中最早的timestamp是T，就分别请求follow的人在T之前的100条feed，然后再进行合并？答：对 问：如果恰好有几条feed的timestamp一样该如何处理？答：首先不会有帖子的timestamp一样，timestamp的精度很高的（微秒级别） 通常来说，翻页这个完全可以作为一道单独的系统设计面试题来问你。翻页并不是简单的1-100，101-200这样去翻页。因为当你在翻页的时候，你的news feed可能已经添加了新的 内容，这个时候你再去索引最新的101-200可能和你的1-100就有重叠了。 通常的做法是，拿第101个帖子的timestamp作为下一页的起始位置，也就是说，当用户在看到第一页的前100个帖子的时候，他还有第101个帖子的timestamp信息（隐藏在你看不到的地方），然后你请求下一页的时候，会带上这个timestamp的信息，server端会去数据库里请求 &gt;= timestamp 的前101个帖子，然后也同样把第101个帖子作为下一页的timestamp。这个方法比直接用第100个帖子的timestamp好的地方是，你如果读不到第101个帖子，说明没有下一页了，如果你刚才只有100个帖子的话，用第100个帖子的timestamp的坏处是，你会有一次空翻。 Web服务器 Web Server 在浏览器输入网址后，这个请求到达的网站提供方那边的一台或者若干台机器。这（些）机器提供HTTP/HTTPS服务。 HTTP/HTTPS 是叫 超文本协议， 主要用于网页浏览器(Web Browser)和网站服务器(Web Server)之间沟通的协议 协议 == 约定好的沟通说话方式 == 传输数据的格式 一台性能好的Web Server大概每秒可以服务1k次访问请求 (粗略的预估) (企业级) (自己搭建的服务器每秒能服务10台就不错啦) (要考虑查询是否复杂) (server有多少个cpu…, 企业的服务器比较好…) Web Server有时候也叫 Application Server 1个request -&gt; 返回1个response (有点像函数调用) 数据库 存储数据的仓库（数据比如，用户信息，用户发的帖子等） 数据库是内网中才能访问的，一般不会对公网提供发问权限 (为了安全性) 数据库一般和Web Server打交道 数据库支持对数据的增删查改，且提供丰富的查询接口 如查询所有2018年入学的算法成绩 &lt; 60 分的同学信息 一个合理的架构中，Web Server 和 Database Server 是两台不同的机器 （一旦有东西出错了，可以方便的定位到是什么出错了；否则放在一起会相互影响，出错了后很难debug） 数据库适合存储结构化数据（Structured Data) -&gt; （能够写成一个class，里面对应的一些attributes） 常见的软件是MySQL 文件系统 File System 操作系统的组成部分之一 一般是目录结构，（访问文件系统需要提供文件目录地址） 数据库系统是基于文件系统而存在的，（数据库系统无法单独存在，数据库的数据最终还是写在文件系统中的一个一个文件里，只不过这些文件怎么组织，格式是什么，我们无需关心，数据库系统会处理好，我们只需要关心数据库的表是什么，里面有什么属性） 文件系统的接口比较单一 读某个文件从某个位置开始的多少字节的数据 在某个文件的某个位置起写入多少字节的数据 （不符合复杂查询需求，所以数据库系统对文件系统进行封装，提供接口给用户使用） 断电之后数据依然存在 -&gt; 持久化 非机构化的数据适合直接存储在文件系统中 如 .avi, .jpg （直接是文件）（如果需要查询文件里面的东西，需要构建新的查询系统专门服务这个查询） 主键和外键主键(Primary Key): 用于唯一和完整标记这条数据的数据列或属性的集合。（ e.g., user_id）一个数据表只能有一个主键，且不能缺失，也不能为空。(SQL型数据库通常不用自己定义主键，因为它默认每个表都带id, 且id是线性增长)(NoSQL型数据库主键不是一个整数，而是一个哈希码字符串，为了可以支持分布式数据库，同时各自创建新的数据，而不用依赖一个结构去创建ID)外键(Foreign Key): 在新的表中，用某个表的主键表示那个表的信息，不需要存冗余信息，（有点像存了reference） id会由于数据太大 而溢出， 所以现在 id 一般要用 Bigint（64位）才不会担心溢出。 数据库索引 Index是什么 类比书的目录 -&gt; 快速查询 有序性 为什么需要Index 可以对数据库表单的任何一项建立索引，用来加速这一项的查询 相当于数据库建了个专门存index的表， 这个index表按照一定顺序很快地查询到待查值所在的位置 加速这两类查询：某个个column等于某个值， 某个column在某个范围（range query） 没有index只能用for循环 -&gt; 超级慢 index的原因 文件上的“有序”列表 传统的关系型数据库一般采用 B+ Tree 做为Index的数据结构 B+树是一棵“排序”多叉树，类似排序二叉树（Binary Search Tree） 通过“多叉”减少树的高度，减少磁盘寻道（Disk Seek）次数 怎么建index &amp; 常用的几类index （建索引语法可以显查） 普通索引 唯一索引（Unique Index）如Primary Key自带的索引，有唯一性。例子User Table 中的Username，Email 联合索引（Composite Index）涉及到两个或多个column的查询，需要建联合索引 条件索引（Condition Index）只对满足条件的数据建索引，查询也是对满足条件的数据做查询]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>系统设计</tag>
        <tag>九章算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【面试笔记】Python，Django]]></title>
    <url>%2F2019%2F05%2F29%2Fnotes--python-django%2F</url>
    <content type="text"><![CDATA[DjangoDjango框架快速上手，是超多开箱即用的工具，快速开发的优先选择。它是由Python写成,采用了MTV的框架模式.即Model, View, Template组成。 说到底,其实Django内部就是对Socket连接的强大封装。 模型（Model），即数据存取层（与数据库处理有关的程序）。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。 模板(Template)，即表现层（各种html程序）。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 视图（View），即业务逻辑层（url的处理函数）。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。 Django文件结构123456789101112├── django/ # 项目文件夹，对整个项目进行配置│ ├── setting.py # 项目配置文件│ ├── urls.py # url对应关系，对url的正则表达式分配相应视图│ ├── wsgi.py # 遵循WSIG规范, uwsgi + nginx│ └── manage.py # 管理Django 程序├── app/ # app， 应用程序文件夹│ ├── migrations/ # 数据库操作记录，相应表结构发生变化│ ├── admin.py # Django为我们提供的后台管理│ ├── apps.py # 配置当前APP│ ├── models.py # ORM,写指定的类通过命令可以创建数据库结构│ ├── tests.py # 单元测试│ └── views.py # 业务逻辑代码 Django原理Django请求的生命周期 当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端, 请求头和请求体中会包含浏览器的动作(action),这个动作通常为get或者post,体现在url之中. url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. 视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django把客户端想要的数据做为一个字符串返回给客户端. 客户端浏览器接收到返回的数据,经过渲染后显示给用户. 业务流程原理url请求—-&gt;访问路由系统(负责分发请求到相应视图函数)——&gt;视图函数(处理请求)——&gt;DataBase(数据库操作数据生成对应页面返回给用户)这个过程中Django主要做了两件事：处理 Request和创建Response， 而它们对应的核心就是urls分析、模板技术和ORM技术。 具体步骤如下： 用户通过浏览器请求一个页面 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求 URLConf通过urls.py文件和请求的URL找到相应的View View Middlewares被访问，它同样可以对request做一些处理或者直接返回response 调用View中的函数 View中的方法可以选择性的通过Models访问底层的数据 底层实现原理本质是Django就是一个Socket服务端,用户的浏览器其实就是一个Socket客户端.用户访问网站的过程就是服务端与客户端Socket通信的过程。 WSGI协议WSGI TutorialWSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。uwsgi：与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等 WSGI协议主要包括server和application两部分： WSGI server: 负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application: 接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。 WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和application组合实现自己的web应用。 Django WSGI applicationWSGI application接口应该实现为一个可调用对象，例如函数、方法、类、含call方法的实例。这个可调用对象可以接收2个参数： 一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env）； 一个用于发送HTTP响应状态（HTTP status ）、响应头（HTTP headers）的回调函数。同时，可调用对象的返回值是响应正文（response body），响应正文是可迭代的、并包含了多个字符串。 可以看出application的流程包括: 加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号； 处理请求，调用get_response()方法处理当前请求，该方法的的主要逻辑是通过urlconf找到对应的view和callback，按顺序执行各种middleware和callback。 调用由server传入的start_response()方法将响应header与status返回给server。 返回响应正文 Django WSGI Server负责获取http请求，将请求传递给WSGI application，由application处理请求后返回response。 配置服务器: Nginx vs ApacheNginx相对Apache 的优点： 轻量级，同样起web 服务，比apache占用更少的内存及资源 抗并发，Nginx处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下Nginx 能保持低资源低消耗高性能高度模块化的设计，编写模块相对简单 社区活跃，各种高性能模块出品迅速啊 Nginx配置简洁, Apache复杂 Apache相对Nginx的优点： rewrite ，比nginx的rewrite强大 模块超多，基本想到的都可以找到 少bug ，nginx的bug相对较多超稳定 Nginx的优势是处理静态请求，cpu内存使用率低，Apache适合处理动态请求，所以现在一般前端用Nginx作为反向代理抗住压力，apache作为后端处理动态请求。最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程。需要性能的web服务，用Nginx。如果不需要性能只求稳定，那就Apache。 Django内置组件 Admin是对model中对应的数据表进行增删改查提供的组件 model组件：负责操作数据库 form组件：1.生成HTML代码2.数据有效性校验3校验信息返回并展示 ModelForm组件即用于数据库操作,也可用于用户请求的验证 Django中间件 process_request : 请求进来时,权限认证 process_view : 路由匹配之后,能够得到视图函数 process_exception : 异常时执行 process_template_responseprocess : 模板渲染时执行 process_response : 请求有响应时执行 cookie vs session cookie: cookie是保存在浏览器端的键值对,可以用来做用户认证 session：将用户的会话信息保存在服务端,key值是随机产生的字符串,value值是session的内容, 依赖于cookie将每个用户的随机字符串保存到用户浏览器上Django中session默认保存在数据库中：django_session表 参考资料 Python篇-Django框架详解(一) Django框架–底层架构 理解Python WSGI 做python Web开发你要理解：WSGI &amp; uwsgi Django面试题(21道) Python全局解释器锁线程全局锁(Global Interpreter Lock), 即Python为了保证线程安全而采取的独立线程运行的限制, 说白了就是一个CPU只能在同一时间运行一个线程. 无论系统上存在多少个可用的CPU核心，Python程序只能在一个处理器上运行。]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【重读课本】操作系统概念]]></title>
    <url>%2F2019%2F05%2F29%2Fnotes--operating-system%2F</url>
    <content type="text"><![CDATA[最近找工作的过程中，面试都问到了操作系统，而且是操作系统很基础的知识。然而，我都忘了… 换句话说，你忘了，就是在面试官心目中你不会。为了不再丢人，我决定好好重读课本，也算是巩固一下基础，努力做个好程序员。 因为面试过程中问的比较多的是进程和线程。那我就不按课本的顺序，先从线程开始。 进程 &amp;概念 进程： 一个程序在一个数据集合上的一次运行。所以一个程序在不同的数据集合上运行，乃至一个程序在同样的数据集合上的多次运行都是不同的进程。（如，浏览器打开多个页面） 线程：线程是进程中的一个实体，是被系统独立调度和执行的基本单位。 作业：用户在一次解题或一个事务处理过程中要求计算机系统所做的工作的集合。它包括用户程序，所需要的数据以及控制命令等。作业是一系列有序的步骤组成的。 管程：管程实际上是定义了一个数据结构和在该数据结构上的能为并发进程所执行的一组操作，这组操作能同步进程和改变进程中的数据。 进程状态 就绪(Ready): 当进程已分配到了除CPU以外的所有必要的资源，只要获得处理器就可以立即执行 执行(Running): 当进程获得了处理器，程序真正处理器上执行 阻塞(Blocked): 正在执行的进程，由于等待某个事件的发生而无法执行时，就放弃处理器而处于阻塞状态。引起阻塞的事件很多，如等待IO，申请缓冲区不能满足，等待信号等等 线程为什么需要线程在完成一个事件如果要创建多个进程实现（如MP3播放器），多个进程又存在问题： - 进程之间通信和共享资源开销大 - 维护进程的系统开销大：创建进程时，要分配资源和建立PCB；撤销进程时，回收资源和撤销PCB；进程切换时，保存当前进程的状态。 线程与进程的比较 进程时资源分配单位，线程时CPU的调度单位； 进程拥有一个完整的资源平台，线程只独享不可少的的资源如寄存器和栈。 进程间是独立的，这表现在内存空间和上下文环境上，线程是运行在进程空间内。 通常情况下，进程无法存储其他进程内的存储空间；而线程与它同属一进程的其他线程共享代码段，数据段和其他操作系统资源，它们共享同一内存空间； 同一进程中的两段代码不能同时执行，除非引入多进程 线程是属于进程的，当进程退出时该进程产生的所有线程都会被强制退出并清除。 进程间有IPC通信，线程没有 线程同样有就绪，阻塞和执行三种基本状态 线程能减少并发执行的时间和空间开销： 线程的创建时间比进程短 线程的终止时间比进程短 同一进程内的线程切换时间比进程短 由于同一进程的各线程之间共享内存和文件资源，可以直接进行不需要通过内核的通信 动态链接库 VS 静态链接库静态库包括了代码，地址符号等；而导入库（动态库）实际的执行代码位于动态库中。静态库要参与编译，在生成执行文件工程中，要将静态库的所有指令全部接入执行文件中。所以，生成执行文件后，静态链接库.lib文件可以弃之不用。动态链接库是作为共享函数的可执行文件。动态链接提供一个方法，使进程可以调用不属于它的可执行代码的函数。函数的执行代码位于.dll文件中，它包含了一个或多个已经被编译，链接并于使它们的进程的函数。 dll的优点：节省内存，减少交换操作，节省磁盘空间，更易于升级（不需要重链接和重编译），提供售后服务，提供拓展MFC库类的机制，支持多语言程序。静态链接库可能比动态链接库快。 进程之间的通信进程之间的通信有：信号，管道，消息队列，共享内存 信号：操作系统向应用程序发出信号，应用程序会：crash(直接退出)， ingore，catch(获取信号并处理，处理完后再回到原来的程序继续执行)。但是信号不能共享数据段。 管道：某个进程的输出是某个进程的输入，由操作系统决定 消息队列： 直接通信：建立链接 间接通信：一个消息队列可以被多个进程所共享；共享消息队列的进程发送的消息中除了message本身外还有一个标志，这个标志可以指明该消息由哪个进程或哪类进程接受。每一个共享消息队列也有自己的标志，表明自己的身份 共享内存： 通常操作系统试图阻止一个进程访问另外一个进程的内存。共享内存需要两个或更多的进程取消这个限制， 它们通过在共享区域内读写交换信息。 数据的形式或位置取决于这些进程而不受控于操作系统。 进程还要保证它们不向同一区域同时写数据：生产者–消费者；如一个Web服务器生产（提供）HTML文件和图像，它们被请求资源的客户Web浏览器所消费(读取)。 死锁死锁产生条件： - 互斥条件 - 请求与保持条件 - 不剥夺条件 - 循环等待条件 占有一些资源，并循环等待 预防和解除： - 对进程发出的能过满足的资源请求进行动态检查，并根据检查结果决定是否分配资源 - 防止进程在等待状态的情况下占有资源 处理死锁基本方法: - 预防死锁(摒弃除1以外的条件) - 避免死锁(银行家算法) - 检测死锁(资源分配图) - 解除死锁 - 剥夺资源 - 撤销进程 调度]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Operating System</tag>
        <tag>重读</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用笔记]]></title>
    <url>%2F2019%2F05%2F29%2Fhexo-notes%2F</url>
    <content type="text"><![CDATA[Hexo的官方文档如下： https://hexo.io/docs/https://hexo.io/zh-cn/docs/ 为了方便，我把一些常用的指令记录下来。 常用指令 new: 新建一篇文章 1$ hexo new [layout] &lt;title&gt; Hexo 有三种默认布局：post、page 和 draft。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate: 生成静态文件 1$ hexo generate 选项: - -d, --deploy: 文件生成后立即部署网站 - -w, --watch: 监视文件变动 该指令可以简写为 hexo g publish: 发表草稿 1$ hexo publish [layout] &lt;filename&gt; server: 启动本地服务器 1$ hexo server 默认情况下，访问网址为： http://localhost:4000/。 deploy: 部署 1$ hexo deploy 该命令可以简写为：hexo d clean: 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean 在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那就可能需要运行该命令。 list: 列出网站资料 1$ hexo list &lt;type&gt; Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量。预定义的参数有：layout, title, date, updated, comments, tags, categories, permalink. 并列分类：123categories:- [Linux]- [Tools] 并列+子分类：123categories:- [Linux, Hexo]- [Tools, PHP] 参考资料 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 Hexo 搭建个人博客系列：主题美化篇 用Live2D让看板喵入住你的Hexo博客吧(^o^)/~]]></content>
      <categories>
        <category>Technique</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing testst Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
